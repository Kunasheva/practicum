Пункты с 1 по 7 реализованы в файлах client.py и server.py 2 пункт. Клиент вводит exit и разрывает соединение
![image](https://user-images.githubusercontent.com/90391164/138722177-e6bdc64b-048d-4161-a9ac-fd102e367bcb.png)

пункт 4. Ввод IP адреса и порта. Безопасный ввод - модуль getpass, значения по умолчанию установлены.
![image](https://user-images.githubusercontent.com/90391164/138722227-2ada85f5-eab5-4153-810b-1c3e019c0506.png)

5 пункт. Модифицировать код сервера таким образом, чтобы все служебные сообщения выводились не в консоль, а в специальный лог-файл. Используем библиотеку sys
![image](https://user-images.githubusercontent.com/90391164/138722297-3f90e689-c13c-4f2a-849e-e2270ca3daad.png)

6 пункт. Модифицируйте код сервера таким образом, чтобы он автоматически изменял номер порта, если он уже занят. Сервер должен выводить в консоль номер порта, который он слушает.
![image](https://user-images.githubusercontent.com/90391164/138722330-bb06cd9c-f159-4814-89be-f113b3a81851.png)
![image](https://user-images.githubusercontent.com/90391164/138722347-e7966c47-17c0-4e88-b77b-8132348fd15a.png)

7 пункт. Сервер идентификации. Запросили у пользователя имя
![image](https://user-images.githubusercontent.com/90391164/138722388-73e49721-e2d0-4752-9464-4fe77f53eb8c.png)

сервер нас приветствует
![image](https://user-images.githubusercontent.com/90391164/138722436-4889169e-2c46-4e20-8554-a463f7df404e.png)

Пункты с 8 по 10 реализованы в файлах client.py и server.py
8 пункт. Реализовать сервер аутентификации. Похоже на предыдущее задание, но вместе с именем пользователя сервер отслеживает и проверяет пароли. Дополнительные баллы за безопасное хранение паролей. Дополнительные баллы за поддержание сессии на основе токена наподобие cookies
При первом подключении сервер попросил придумать пароль, далее он сохранил пароль и уже предложил авторизоваться. Пароли в файлах хранятся в хешированном виде с ипользованием алгоритма шифрования md5. При авторизации сервер отправляет клиенту токен, который действует одну сессию, при отправке сообщения клиентом, к нему добавляется токен, сервер проверяет верен ли токен, если токен верен, сервер обрабатывает сообщение. информация о логине/пароле сохраняется в зашифрованном виде в csv файл.
![image](https://user-images.githubusercontent.com/90391164/138722535-9e729ab2-3507-4719-9e80-951726160043.png)
![image](https://user-images.githubusercontent.com/90391164/138722548-fcfb8bc0-4d63-437c-976a-5682ccd23bf2.png)

9 пункт. Напишите вспомогательные функции, которые реализуют отправку и принятие текстовых сообщений в сокет. Функция отправки должна дополнять сообщение заголовком фиксированной длины, в котором содержится информация о длине сообщения. Функция принятия должна читать сообщение с учетом заголовка. В дополнении реализуйте преобразование строки в байтовый массив и обратно в этих же функциях. Дополнително оценивается, если эти функции будут реализованы как унаследованное расширение класса socket библиотеки socket.
работа отправки/ приемки сообщений приведена в пункте 8, там можно увидеть, что выводится длина сообщений, а сообщения передаются как байтовые массивы, причем вспомогательные куски на экран не выводятся. Функции реализованы отдельно и созданы как унаследованное расширение класса socket. Функции приема отправки клиента
![image](https://user-images.githubusercontent.com/90391164/138722600-e23301c9-5329-4c84-9b78-9e41f08dd56f.png)

Функции приема отправки сервера
![image](https://user-images.githubusercontent.com/90391164/138722671-f53df706-b0af-4784-85b8-ff3aebfd9c95.png)

10 пункт. Дополните код клиента и сервера таким образом, чтобы они могли посылать друг другу множественные сообщения один в ответ на другое. Как видим сервер и клиент могут переписываться последовательно. Слева сообщения сервера, справа клиента.
![image](https://user-images.githubusercontent.com/90391164/138722716-acbfb821-cf58-4da0-8364-a505552670b0.png)

